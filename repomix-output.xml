This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
dccs/SN-923-diagram.md
dccs/SN-923-stats.md
specs/01_requirements.md
specs/02_data_model.md
specs/03_ui_ux.md
specs/04_logic_api.md
specs/05_architecture.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="dccs/SN-923-stats.md">
---
config:
  layout: elk
  theme: redux-dark
---
stateDiagram
  direction TB
  [*] --> READY:製造オーダー発行
  READY --> PRINTING:1個体DL開始
  PRINTING --> CUTTING
  CUTTING --> SANDING
  SANDING --> INSPECTION
  INSPECTION --> COMPLETED:合格
  INSPECTION --> SANDING:修正可能(戻り)
  INSPECTION --> DISCARD:修正困難
  COMPLETED --> SHIPPED:組立投入
  PRINTING --> DISCARD:造形失敗
  CUTTING --> DISCARD:切削失敗
  SANDING --> DISCARD:研磨失敗
  SHIPPED --> DB
  DISCARD --> DB
  INSPECTION --> CUTTING:修正可能
  READY:READY (Box確保済)
  PRINTING:PRINTING (DL実行)
  INSPECTION:INSPECTION (検査)
  COMPLETED:COMPLETED (合格)
  DISCARD:DISCARD (Box解放)
  SHIPPED:SHIPPED (Box解放)
  DB:実績DB (s4)
  note right of DISCARD 
  どの工程からでも遷移可能
      遷移時に自動でBox解放
  end note
</file>

<file path="dccs/SN-923-diagram.md">
---
config:
  theme: dark
  layout: elk
---
flowchart LR
 subgraph UI["UI層 (Next.js App)"]
        ImportUI["インポート画面<br>(設計登録)"]
        OrderUI["製造指示画面<br>(指示発行)"]
        BoardUI["工程管理ボード<br>(ステータス操作)"]
        DetailUI["部品詳細・DL画面<br>(ファイル取得)"]
  end
 subgraph Logic["ロジック層 (Server Actions / API)"]
        ImportLogic["インポート処理<br>(BOM登録)"]
        OrderLogic["製造実行処理<br>(個体生成)"]
        StatusLogic["ステータス更新処理<br>(履歴保存)"]
        DownloadLogic["署名付きURL発行処理<br>(DL管理)"]
  end
 subgraph DB["DB層 (Neon / Postgres)"]
        Unit["Unit"]
        Project["Project"]
        Part["Part<br>(stl_url保持)"]
        PartItem["PartItem<br>(status保持)"]
        History["StatusHistory<br>(変更ログ)"]
        Box["Boxマスタ"]
        Machine["Machine<br>(造形機マスタ)"]
  end
 subgraph External["外部リソース"]
        Storage["Firebase Storage<br>(STLファイル)"]
  end
    Project --- Unit
    Unit --- Part
    Part -. 生成 .-> PartItem
    PartItem --- History & Box
    PartItem --- Machine
    BoardUI -- ドラッグ&ドロップ等 --> StatusLogic
    StatusLogic -- Update status --> PartItem
    StatusLogic -- Insert record --> History
    StatusLogic -- "Release Box<br>(if Discard/Shipped)" --> Box
    DetailUI -- DLリクエスト --> DownloadLogic
    DownloadLogic -- URLリクエスト --> Storage
    Storage -- 一時的な閲覧URL --> DetailUI
    ImportUI --> ImportLogic
    ImportLogic -- 部品番号 --> Part
    OrderUI --> OrderLogic
    OrderLogic --> PartItem
    ImportLogic -- STLファイル --> Storage
    n1["STLファイル"] --> ImportUI
    Part -- 部品名を取得 --> OrderLogic
    History -- ステータスを取得 --> StatusLogic
    StatusLogic -- カンバンボードなどに反映 --> BoardUI
    DownloadLogic --> DetailUI

    n1@{ shape: text}
     n1:::Ash
    classDef Aqua stroke-width:1px, stroke-dasharray:none, stroke:#46EDC8, fill:#DEFFF8, color:#378E7A
    classDef Ash stroke-width:1px, stroke-dasharray:none, stroke:#999999, fill:#EEEEEE, color:#000000
    style BoardUI fill:#fff9c4,stroke:#fbc02d
    style DetailUI fill:#fff9c4,stroke:#fbc02d
    style StatusLogic fill:#fff9c4,stroke:#fbc02d
    style DownloadLogic fill:#fff9c4,stroke:#fbc02d
    style History fill:#f1f8e9,stroke:#33691e
</file>

<file path="specs/01_requirements.md">
# 要件定義書 (Draft)

## 1. システム概要
本システムは、製造現場における部品（Part）の設計データ管理および、その個体（PartItem）の製造進捗・ステータスを管理するための工程管理システムである。
データ構造として、プロジェクト（Project）、ユニット（Unit）、部品（Part）の3階層で構成されるBOM構造をサポートする。

## 2. 背景・目的
- 3Dデータ（STLファイル）をベースとした部品情報の迅速な登録。
- 製造・切削・研磨・検査等の各フェーズにおけるリアルタイムな進捗把握と品質管理。
- 個体ごとの製造履歴（使用した造形機を含む）および保管場所（Box）の紐付け管理。

## 3. 主要機能範囲
### 3.1 設計管理
- **BOM登録**: プロジェクト・ユニット構成を含む設計データ（STLファイル）のインポート。
- **ファイル管理**: 外部ストレージを用いた設計データのセキュアな保存と取得。

### 3.2 製造管理
- **製造指示**: 部品から特定の個体（PartItem）を生成し、造形機（Machine）を割り当てる。
- **ステータス管理**: かんばん方式等のUIを用いた直感的な工程更新（プリント、切削、研磨、検査、完了、出荷、廃棄）。
- **履歴追跡**: ステータス変更時のログ自動記録。

### 3.3 物理管理
- **保管管理**: 部品個体と物理的な保管場所（Box）の紐付け。
- **自動解放**: 廃棄(DISCARD)時または出荷(SHIPPED)時に保管場所（Box）を自動で空き状態にする。

## 4. MVP開発スコープ (Phase 1)
本フェーズでは、以下の3軸の機能実現を最優先とし、認証・権限管理は行わない。

### 4.1 設計管理 (Design Management)
- 部品情報の定義とSTLファイルの紐付け（BOM登録）。
- クラウドストレージを用いた3Dデータの一元管理。

### 4.2 製造管理 (Production Management)
- 製造指示（個体生成）とステータスの可視化。
- 工程履歴の自動記録。

### 4.3 物理管理 (Physical Management)
- 部品個体と保管場所（Box）の紐付け。
- 保管場所の空き状況管理。

## 5. 将来拡張事項 (Phase 2 以降)
- **ユーザー認証・権限管理**: 設計者、指示者、作業者ごとのアクセス制御。
- **高度な検索・フィルタリング**: 大規模プロジェクト向けの部品検索機能。
- **外部システム連携**: ERPや既存BOMシステムとの同期。
</file>

<file path="specs/03_ui_ux.md">
# UI/UX仕様書 (Draft)

## 1. 画面一覧

| 画面名 | ID | 概要 |
| :--- | :--- | :--- |
| インポート画面 | `ImportUI` | STLファイルを用いた設計データの一括登録 |
| 製造指示画面 | `OrderUI` | 部品を選択し、製造個体（PartItem）を生成 |
| 工程管理ボード | `BoardUI` | 部品個体のステータスを一覧・操作するメインUI |
| 部品詳細画面 | `DetailUI` | 個別の部品情報の確認、STLファイルのダウンロード |

## 2. 画面詳細

### 2.1 工程管理ボード (`BoardUI`)
- **構成**: かんばん（Swimlane）形式。
- **ステータス列**: `READY`, `PRINTING`, `CUTTING`, `SANDING`, `INSPECTION`, `COMPLETED`, `SHIPPED`, `DISCARD` の各工程を表示。
- **操作**:
    - ドラッグ＆ドロップによるステータス遷移（戻り遷移も含む）。
    - 各個体（PartItem）のカードには、使用した造形機名や保管場所（Box名）を表示。
    - ステータス変更時にバックエンドの `StatusLogic` を呼び出し、DB更新と履歴記録を行う。

### 2.2 インポート画面 (`ImportUI`)
- **構成**: プロジェクト/ユニット選択、ファイルドロップエリア、ファイル名解析プレビュー。
- **特徴**:
    - 所属する **プロジェクトおよびユニット** を事前に選択（または新規作成）。
    - ファイル名から部品番号を自動抽出。
    - 不足している `Part` レコードの自動生成。

## 3. インラカクション方針
MVPフェーズではアクセス制限を設けず、利便性を追求する。
- **設計管理**: インポート画面での自動解析による「考えさせない登録」。
- **製造管理**: ドラッグ＆ドロップによる直感的なステータス変更。
- **物理管理**: 保管場所（Box）の選択をフローに組み込み、入力負荷を軽減。

## 4. 共通デザイン要件
- **レスポンシブ**: 製造現場のタブレット端末でも操作しやすいボタンサイズ。
- **フィードバック**: 通信中やエラー時のトースト通知、スケルトンスクリーン。
</file>

<file path="specs/02_data_model.md">
# データモデル定義書 (Draft)

## 1. エンティティ関係図 (ERD)

```mermaid
erDiagram
    PROJECT ||--o{ UNIT : contains
    UNIT ||--o{ PART : defines
    PART ||--o{ PART_ITEM : generates
    PART_ITEM ||--o{ STATUS_HISTORY : "logged in"
    PART_ITEM ||--o| BOX : "stored in"
    MACHINE ||--o{ PART_ITEM : "processes"

    PROJECT {
        string id PK
        string name
    }
    UNIT {
        string id PK
        string project_id FK
        string name
    }
    PART {
        string id PK
        string unit_id FK
        string part_number
        string stl_url
    }
    PART_ITEM {
        string id PK
        string part_id FK
        string machine_id FK "使用したプリンタ"
        string box_id FK "現在の保管場所"
        string status
        datetime updated_at
    }
    MACHINE {
        string id PK
        string name "プリンタ名"
        string type "SLA/FDM等"
        string status "READY/RUNNING/MAINTENANCE"
    }
    STATUS_HISTORY {
        string id PK
        string part_item_id FK
        string status_from
        string status_to
        datetime changed_at
    }
    BOX {
        string id PK
        string name
        string status "AVAILABLE/OCCUPIED"
    }
```

## 2. テーブル詳細

### 2.1 Part (部品マスタ)
設計データの基本単位。
- `id`: 内部ID
- `part_number`: 型番・図番
- `stl_url`: Firebase Storage上のパス
- `status`: インポート進捗状態
    - `PENDING`: DB登録済み、ファイルアップロード待ち
    - `ACTIVE`: ファイルアップロード完了、利用可能

### 2.2 PartItem (個体データ)
製造現場で実際に動く「モノ」の単位。
- `id`: シリアルID
- `status`: 現在の工程（例: 待機、製造中、検査済、出荷済）
- `box_id`: 物理的な棚や箱のID

### 2.3 StatusHistory (履歴)
トレーサビリティのための変更ログ。
- `part_item_id`: 対象個体
- `status_from / status_to`: 遷移前後
- `changed_at`: 変更日時

### 2.4 Box (保管場所)
- `name`: 場所名（棚A-1等）
- `status`: 空き状況の管理
</file>

<file path="specs/04_logic_api.md">
# ロジック・API仕様書 (Draft)

## 1. 業務パイプライン (Pipelines)
各ロジックは `specs/05_architecture.md` で定義されたパイプライン層として実装され、複数のサービスをオーケストレートする。

### 1.1 部品インポートパイプライン (`ImportPipeline`)
- **入力**: `files: File[]`, `projectId: string`, `unitId: string`
- **実装方針**: 
    - 開発コスト削減およびデータ不整合防止のため、すべてのステップを **同期処理（直列実行）** で行う。
    - ユーザーはアップロードから本登録完了まで画面上で待機し、途中でバックグラウンド処理への移行は行わない。
- **ステップ**:
    1. **プレ登録 (Pending)**: 
        - ファイル名から `part_number` を抽出。
        - DBに `status: "PENDING"` で `Part` レコードを作成し、一意のIDを確保。
    2. **ストレージ保存**: 
        - 確保したIDをディレクトリ構造やファイル名に含めて Firebase Storage へアップロード（例: `parts/{id}/file.stl`）。
    3. **本登録 (Activate)**: 
        - アップロード成功を受けて、DBの `stl_url` を更新し、`status: "ACTIVE"` に変更。
    4. **クリーンアップ (非同期/エラー時)**:
        - 失敗時は必要に応じて `PENDING` レコードを削除、またはリトライト対象とする。

### 1.2 製造オーダーパイプライン (`OrderPipeline`)
- **入力**: `partId: string`, `machineId: string`, `quantity: number`
- **ステップ**:
    1. **事前チェック**: 部品の存在確認と基本情報の取得。指定数以上の空きBoxがあるか確認。
    2. **ドメイン操作 (トランザクション内)**:
        - **空きBox確保**: 
            - `Box` テーブルから `status: "AVAILABLE"` かつ最小IDのレコードを、`quantity` 分取得。
            - **排他制御**: `SELECT FOR UPDATE` 等を用いて、取得対象のBoxレコードをロックする。
        - **Boxステータス更新**: 取得したBoxのステータスを `"OCCUPIED"` に更新。
        - **個体生成**: 取得した `box_id`, `machine_id` と紐付けた `PartItem` レコードを `quantity` 分一括生成（初期ステータス: `READY`）。
        - **履歴記録**: 各個体の初期履歴を `HistoryService` で記録。

### 1.3 ステータス遷移パイプライン (`StatusUpdatePipeline`)
- **入力**: `itemId: string`, `newStatus: string`
- **ステップ**:
    1. 遷移ルールチェック（`dccs/SN-923-stats.md` に基づくバリデーション。戻り遷移や造形失敗等も考慮）。
    2. `ProductionControlService` により `PartItem` のステータスを更新。
    3. `HistoryService` により遷移ログを保存。
    4. ステータスが `SHIPPED` または `DISCARD` の場合、`StorageLogisticsService` を通じて `Box` を解放。

### 1.4 ダウンロードURL発行パイプライン (`DownloadPipeline`)
- **入力**: `partId: string`
- **ステップ**:
    1. 部品のアクセス権限（存在確認）チェック。
    2. `StorageService` を経由して一時的な閲覧URLを取得。

## 2. バリデーションルール
- STLファイルのバリデーション（サイズ、拡張子）。
- ステータス遷移の整合性チェック（例: 完了済みから未着手への不用意な戻りを制限など）。
</file>

<file path="specs/05_architecture.md">
# アーキテクチャ設計書 (Draft)

## 1. モジュール分割方針
エージェントによるSDD実装を円滑に進めるため、ドメインに基づいたモジュール分割（Modular Monolith）を採用する。各モジュールは、自身のUI、ロジック、データアクセスをカプセル化する。

### 1.1 ディレクトリ構造
```text
src/
├── modules/
│   ├── design-registry/      # 【設計管理】BOM登録、STL解析、Partマスタ
│   ├── production-control/   # 【製造管理】個体生成、ステータス、履歴
│   └── storage-logistics/    # 【物理管理】Box(保管場所)マスタ、空き状況
├── shared/                   # 【共有】型定義、DBクライアント、共通Utils
└── app/                      # 【UI層】Next.js App Router (Page, Layout)
```

### 1.2 モジュール内部の標準構成
エージェントへの指示を統一するため、以下のサブディレクトリ構成を遵守する。
- `actions/`: UIからのリクエストを受け付ける Server Actions。
- `pipelines/`: 複数のサービスを跨ぐ一連の業務フロー（オーケストレーション）。
- `services/`: 特定のテーブル/エンティティに対するDB操作などのコアドメインロジック。
- `components/`: モジュール固有のReactコンポーネント。
- `types/`: モジュール固有の型定義。

## 2. パイプライン層の導入
ロジック層（Actions）とコアドメイン層（Services）の間に **Pipeline層** を配置する。

### 2.1 役割
- **オーケストレーション**: 複数のService関数の実行順序を制御。
- **トランザクション管理**: 複数テーブルに跨る更新のアトミック性を保証。特にBox割り当て時などは `SELECT FOR UPDATE` 等による適切なロックを行い、競合を防止する。
- **バリデーション**: 業務ルールに基づいた遷移可否等の事前チェック。

### 2.2 処理の流れ（例：ステータス更新）
1. `BoardUI` が `StatusAction` を呼び出す。
2. `StatusAction` が `updateStatusPipeline` を呼び出す。
3. `updateStatusPipeline` 内で以下を実行：
    - `PartItemService.validateTransition()`
    - `DB.transaction` を開始
    - `PartItemService.updateStatus()`
    - `HistoryService.record()`
    - `StorageService.releaseBoxIfDone()` (必要に応じて)
    - トランザクション・コミット

## 3. 実装の制約・ガイドライン
- **疎結合**: モジュール間の直接的なService呼び出しは避け、必要に応じてモジュールを跨ぐPipelineを作成する。
- **副作用の明示**: 外部ストレージ操作や通知などの副作用はPipeline層、またはその上位のAction層で管理し、Service層はDB操作に集中させる。
- **不整合防止策**: ストレージとDBの不整合を防ぐため、外部リソース保存前にIDを確定させる「Pending-Activateパターン」を基本とする。
</file>

</files>
